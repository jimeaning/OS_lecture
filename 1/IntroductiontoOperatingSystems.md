# 1강
운영체제란 무엇인가, 운영체제의 목적, 운영체제의 분류, 운영체제의 예, 운영체제의 구조

<br>

### 🤖 운영체제
- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
- 하드웨어 바로 위에 설치되는 소프트웨어
- 운영체제가 없다면 컴퓨터 하드웨어는 고철에 지나지 않음. 혹은 굉장한 실력을 갖춘 사람만이 사용할 수 있을 것.
- 사용자와 소프트웨어는 직접 하드웨어에 접근하지 않으면서 사용 가능


<img src="https://velog.velcdn.com/images/jimeaning/post/f018e7ff-4a64-4532-ae67-46a30d34df34/image.png" width="400">

- 좁은 의미의 운영체제(=커널)
	- 운영체제의 핵심 부분으로 메모리에 상주하는 부분
    - 전공자 입장에서 운영체제는 보통 커널만을 의미
- 넓은 의미의 운영체제
	- 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념
    - 메모리에 상주하지 않는 독립적인 프로그램이지만 운영체제 범주 안에는 포함시킴

<br>

### 🤖 운영체제의 목표
사용자/소프트웨어와 어떻게 인터랙션을 할 것인가(1), 하드웨어와 어떻게 인터페이스를 하는가(2)

1. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
	- 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 느낌을 제공
    - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 다룸
    
2. 컴퓨터 시스템의 **자원을 효율적으로 관리** (운영체제의 의미이기도 함)
	- 프로세서, 기억장치, 입출력 장치 등의 효율적 관리 (하드웨어 자원)
    	- 사용자 간 형평성 있는 자원 분배
        평균적으로 전체 성능도 좋아야 하지만 형평성도 중요. 특정 프로그램이나 사용자가 너무 차별을 받아서는 안 된다.
        - 주어진 자원으로 최대한의 성능을 내도록
    - 사용자 및 운영체제 자신의 보호
    - 프로세스, 파일, 메시지 등을 관리 (소프트웨어 자원)
    
자원 : CPU, 메모리, 입출력 장치, 보조 기억장치(하드 디스크 등)..

![](https://velog.velcdn.com/images/jimeaning/post/b6913df5-3ba7-4ca4-a980-d503849d0f14/image.png)

<br>

### 🤖 운영체제의 분류
#### 1) 동시 작업 가능 여부
- 단일 작업 (single tasking)
한 번에 하나의 작업만 처리
예) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음
- 다중 작업 (multi tasking)
동시에 두 개 이상의 작업 처리. 현재는 대부분 다중 작업 운영체제.
예) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

#### 2) 사용자의 수
- 단일 사용자 (single user)
ex) MS-DOS, MS Windows

- 다중 사용자 (multi user)
ex) UNIX, NT server

<img src="https://velog.velcdn.com/images/jimeaning/post/d4260b6d-0c02-4f74-9708-ff0fd379d9c1/image.png" width="200">


#### 3) 처리 방식
- 일괄 처리 (batch processing)
	- 작업 요청의 일정량 모아서 한꺼번에 처리 (interactive하지 않음)
    - 작업이 완전 종료될 때까지 기다려야 함
    - 예) 초기 Punch Card 처리 시스템  
  
    ![](https://velog.velcdn.com/images/jimeaning/post/8e34e2f2-f15a-4459-9e3c-c15e6d3fadc2/image.png)

    
- 시분할 (time sharing)
	- 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
    - 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
    - 예) UNIX
    - interactive한 방식 (키보드를 두들겼을 때 바로 화면에 나오는 거)
    - 현대에 많이 사용
    - 시간을 분할해서 조금씩 할당하는 것
    - 시간의 제약조건이 있지는 않아서 사람들이 많아지면 동작 처리가 늦어짐

- 실시간 (Realtime OS)
	- 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
    - 특수한 목적을 가진 시스템에서 반드시 정해진 시간 내에 실행될 수 있도록 해야 하는 것이 시분할과 다른 점이다
    - 예) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
    
    - 실시간 시스템의 개념 확장
      - Hard realtime system (경성 실시간 시스템) : 데드라인이 있고 어긋나면 치명적인 결과를 불러일으킬 수 있는 것.
      - Soft realtime system (연성 실시간 시스템) : 데드라인이 있지만 치명적인 결과가 있지는 않은 것. 예) 영화

	- 요즘은 스마트폰에 실시간이 필요한 응용 프로그램이 많이 늘었음.
    ex) 네비게이션, 블랙박스
    
<br>
    
### 🤖 헷갈릴 수 있는 용어 정리
- Multitasking  
짧은 시간으로 분할해서 빠르게 전환함 -> 사용자는 동시에 프로그램이 실행되고 있다고 느낌. 
하나의 프로그램이 끝나기 전에 다른 프로그램이 실행가능한 것
- Multiprogramming  
메모리에 여러 프로그램이 동시에 올라가는 것.
멀티태스킹이 되려면 메모리에 동시에 올라가야 하긴 하지만, 메모리를 더 강조
- Time sharing  
시간을 공유해서 쓰는 것. CPU를 더 강조한 측면. 
- Multiprocess

위의 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻한다.  
멀티프로그래밍은 여러 프로그램이 메모리에 올라가 있음을 강조  
Time Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조  

- Multiprocessor  
하나의 컴퓨터에 CPU (processor)가 여러 개 붙어 있음을 의미
위에 네 개는 CPU가 하나 있더라도 실행가능한데, 멀티프로세서는 CPU가 여러 개 있어야 함(하드웨어가 다름)

<br>

### 🤖 운영체제의 예
#### 유닉스(UNIX)
- 코드의 대부분을 C언어로 작성
- 어셈블리 언어로 운영체제를 만들기가 까다로워서 기계, 사람에게 모두 가까운 유닉스 운영체제 만듬 (유닉스를 만들기 위해 C언어 탄생)
- 높은 이식성
- 최소한의 커널 구조
- 복잡한 시스템에 맞게 확장 용이
- 소스 코드 공개
- 프로그램 개발에 용이
- 다양한 버전
	- System V(5), FreeBSD, SunOS, Solaris
    - Linux (공개 소프트웨어 정신)

#### DOS(Disk Operating System)
- MS사에서 1981년 IBM-PC를 위해 개발
- 단일 사용자용 운영체제, 메모리 관리 능력의 한계 (주기억장치: 640KB)
- 맥시멈 640KB 이상 필요 없을 거라 했는데 하드웨어 발전에 따라 깨짐

#### MS Windows
- MS사의 다중 작업용 GUI 기반 운영체제
- Plug and Play, 네트워크 환경 강화
- DOS용 응용 프로그램과 호환성 제공
- 불안정성 (발전해서 이제는 많이 해소됨)
- 풍부한 지원 소프트웨어

#### Handheld device를 위한 OS
- PalmOS, Pocket PC (WinCE), Tiny OS

<br>

### 🤖 운영체제의 구조
- CPU 스케줄링  
CPU는 어떤 프로그램에 할당을 할까 결정하는 일  
하나의 프로그램이 CPU를 점유하고 놓지 않으면 뒤에 작업이 계속 기다려서 효율성이 떨어짐  
우선순위가 높은 것이나 빨리 처리할 수 있는 것을 먼저 처리하면 효율성이 높아짐  

    너무 빠르기 때문에 어떻게 관리할 것인가가 이슈

- 메모리 관리  
메모리는 한정되어 있는데 여러 프로그램이 올라가려고 할 때 어떻게 분배할 것인지  

- 파일 관리  
디스크 특성에 맞게 파일을 관리하고, 디스크도 스케줄링이 필요함.  
디스크는 헤드를 움직이면서 데이터를 읽고 쓰기 때문에 헤드에 가까운 요청이 있다면 나중에 들어 왔을지라도 순서를 먼저 처리해서 왔다 갔다를 최소화함 (엘리베이터와 유사!)

    디스크는 헤드가 움직이면서 처리하기 때문에 어떻게 하면 최소한의 움직임으로 처리할 수 있을 것인가

- 입출력 관리  
I/O device를 어떻게 관리할 것인가. 컴퓨터 CPU보다 훨씬 느림.  
interrupt를 걸어서 요청을 보내고 처리함.

    컴퓨터 내부와 교신을 하면서 정보를 처리할 때 어떻게 할 것인지가 이슈가 됨

- 프로세스 관리
  - 프로세스의 생성과 삭제
  - 자원 할당 및 반환
  - 프로세스 간 협력

- 그 외
  - 보호 시스템
  - 네트워킹
  - 명령어 해석기 (command line interpreter)  
  명령을 치고 입력하면 해석해주는 것도 운영체제의 기능

![](https://velog.velcdn.com/images/jimeaning/post/d0090d46-6881-4cc6-becf-bd3b65e83b84/image.png)

